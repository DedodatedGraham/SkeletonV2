#include <stdio.h>
#include <math.h>
#include <time.h>

#include "skeleQuicksort.h"

//First we define a data structure, it will point to the data points
struct skeleData{
    double **points;//This is a pointer to the list of points and normals
    //If 2D then [x, y, normx, normy]
    //if 3D then [x, y, z, normx, normy, normz]
    
    double threshold;//This is a a double which is a distance average of the points
};

struct kdleaf{
    //Bounds and position
    double *origin;//node point [x,y] or [x,y,z]
    double *maxp;//left most point on all axis
    double *minp;//right most point on all axis
    int *depth;

    //lower layers
    struct kdleaf *left,*right; 
};

void CreateStructure(double **points,struct kdleaf *tree,int axis,int *length,int lower,int upper){
    //First we will sort along each needed axis
    if(upper-lower > 5){
        QuickSort(points,lower,upper,axis);
        //points now sorted, Next applying our node point and split the list to the appropiate list
        int nodeindex = (upper - lower) / 2; 
        tree->origin = points[nodeindex];
        //then we spilt the arrays and go deeper
        if(axis == *length - 1){
            axis = 0;
        }
        CreateStructure(points, tree->left, axis + 1, length, lower, nodeindex - 1);
        CreateStructure(points, tree->right,axis + 1, length, nodeindex + 1, upper);
    }
    else{

    }
}

void skeltize(double **points){
    int length = (*(&points[0] + 1) - points[0]) / 2;//gets dimension of skeleton data, should give 2 or 3
    printf("length(dim) is: %d",length);
    int max = *(&points + 1) - points;//gets amount of points being put in
    printf("we have %d points",max);
    struct kdleaf tree;
    CreateStructure(points,&tree,0,&length,0,max);//make kd-tree

}




//void Swap(double *a, double *b){
//    double temp = *a;
//    *a = *b;
//    *b = temp;
//}
//
//int Partition(double **arr, int lbound, int tbound, int index){
//    //lbound => lower bounds
//    //tbound => top bounds
//    double pivot = arr[tbound][index]; 
//    int i = lbound - 1; 
//
//    for(int j = lbound; j < tbound; j++){
//        if(arr[j][index] <= pivot){
//	    i++;
//	    Swap(&arr[i][index], &arr[j][index]);
//	    Swap(&arr[i][index - 1], &arr[j][index - 1]);
//	    Swap(&arr[i][index - 2], &arr[j][index - 2]);
//	    }
//    }
//    Swap(&arr[i + 1][index], &arr[tbound][index]);
//    Swap(&arr[i + 1][index - 1], &arr[tbound][index - 1]);
//    Swap(&arr[i + 1][index - 2], &arr[tbound][index - 2]);
//    int temp_pivot = i+1;
//return temp_pivot;
//}
//
//void QuickSort(double **arr, int lbound, int tbound, int index){
//    if(lbound < tbound){
//        double pivot = Partition(arr, lbound, tbound, index);
//        QuickSort(arr, lbound, pivot - 1, index);
//        QuickSort(arr, pivot + 1, tbound, index);
//    }
//}
